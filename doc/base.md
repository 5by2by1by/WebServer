# 基础知识

    1. 长连接（keep-alive）：只要任意一端没有明确提出断开连接，则保持TCP连接状态。
        好处：减少了TCP连接的重复建立和断开所造成的额外开销，减少了服务器的负载。
        在HTTP/1.1中，所有的连接默认都是持久连接；在 1.0 内并未标准化。

    2. 方法（Method）：
        GET：请求访问已被URI识别的资源；
        POST：传输实体的主体。GET也可以实现，但一般不用GET，POST主要目的并不是获取响应的主题内容。
            GET 用于获取信息，是无副作用的，是幂等的，且可缓存
            POST 用于修改服务器上的数据，有副作用，非幂等，不可缓存
        GET 和 POST 方法没有实质区别，只是报文格式不同。


    3. 无状态（stateless）：
        HTTP不对之前发生过的请求和响应的状态进行管理，也就是，无法根据之前的状态进行本次的请求处理。

    4. cookie技术：
        每次跳转新页面都需要再次登陆，会很麻烦；
        通过在请求和响应报文中写入cookie信息来控制客户端的状态；
        cookie根据服务端发送的响应报文内的一个叫做 Set-Cookie的首部字段信息，通知**客户端保存cookie**,下次客户端再往该服务器发送请求时，客户端会自动携带cookie发送出去；
        服务器发现客户端的cookie之后，会去检查是哪个客户端发来的，对比**服务器上记录**，得到之前的状态信息。

    5. HTTP报文
        由多行（用 CR + LF 作换行符）数据构成的字符串文本。可分为 报文首部 和报文主体 两块，通常并不一定有报文主体。

    6. 比较 报文 和 实体
        报文（message）：是HTTP通信中的基本单位，由8组字节流组成，通过HTTP通信传输；
        实体（entity）：作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。
        HTTP报文的主体用于传输请求或响应的实体主体。
        通常，报文主体 等于 实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它与报文主体发生差异。

## unordered_map

    1. std::unordered_map<std::string, std::string> umap;
    2.  umap.begin()    返回指向容器中第一个键值对的正向迭代器；
        umap.end()      返回指向容器中最后一个键值对之后位置的正向迭代器；
        umap.size()     返回容器中 存有键值对 的个数；
        umap.find(key)  查找以key为键的键值对，如果找到，则返回一个指向该键值对的正向迭代器；反之，则返回一个指向容器中最后一个键值对之后位置的迭代器（如果 end() 方法返回的迭代器）；

## priority_queue

    1. priority_queue 容器适配器定义了一个元素有序排列的队列。默认队列头部的元素优先级最高。因为它是一个队列，所以只能访问第一个元素，这也意味着优先级最高的元素总是第一个被处理。
    2. template <typename T, typename Container=std::vector<T>, typename Compare=std::less<T>> class priority_queue
        example：    std::priority_queue<std::string> words; 
